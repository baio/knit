// Generated by CoffeeScript 1.6.2
(function() {
  define(function() {
    var _setDate;

    ko.bindingHandlers.datetime = {
      init: function(element, valueAccessor, allBindingsAccessor) {
        var dateFormat, dmaxRule, dminRule, maxDate, minDate, opts;

        if (valueAccessor().extend && valueAccessor().extend().rules) {
          dminRule = valueAccessor().extend().rules().filter(function(f) {
            return f.rule === "min";
          })[0];
          if (dminRule) {
            minDate = moment(dminRule.params).toDate();
          }
          dmaxRule = valueAccessor().extend().rules().filter(function(f) {
            return f.rule === "max";
          })[0];
          if (dmaxRule) {
            maxDate = moment(dmaxRule.params).toDate();
          }
        }
        opts = allBindingsAccessor().datetimeOpts;
        dateFormat = opts && opts.dateFormat ? opts.dateFormat : "dd.mm.yy";
        $(element).datepicker({
          minDate: minDate,
          maxDate: maxDate,
          dateFormat: dateFormat,
          beforeShow: function(el) {
            if ($(el).attr('readonly')) {
              return false;
            } else {
              return true;
            }
          }
        });
        ko.utils.registerEventHandler(element, "change", function() {
          var date, observable;

          observable = valueAccessor();
          date = $(element).datepicker("getDate");
          return observable(date);
        });
        return ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
          return $(element).datepicker("destroy");
        });
      },
      update: function(element, valueAccessor) {
        var value;

        value = ko.utils.unwrapObservable(valueAccessor());
        $(element).datepicker("setDate", value ? value : null);
        return valueAccessor()($(element).datepicker("getDate"));
      }
    };
    _setDate = function(element, date, format) {
      if (format == null) {
        format = "DD MMMM YYYY";
      }
      return $(element).text(date ? moment(date).format(format) : "");
    };
    ko.bindingHandlers.displaydate = {
      init: function(element, valueAccessor, allBindingsAccessor) {
        var format, option, valAccessor;

        option = allBindingsAccessor().ddateOpts;
        if (option) {
          format = option.format;
        }
        valAccessor = valueAccessor();
        _setDate(element, ko.utils.unwrapObservable(valAccessor), format);
        if (ko.isObservable(valAccessor)) {
          return valAccessor.subscribe(function(newValue) {
            return _setDate(element, newValue, format);
          });
        }
      }
    };
    ko.bindingHandlers.validationCss = {
      init: function(element, valueAccessor) {
        var f, observable, _setClass;

        observable = valueAccessor();
        f = false;
        _setClass = function(val) {
          if (!val) {
            return $(element).addClass("error");
          } else {
            return $(element).removeClass("error");
          }
        };
        observable.isModified.subscribe(function() {
          f = true;
          return _setClass(observable.isValid());
        });
        observable.isValid.subscribe(function(val) {
          if (f) {
            return _setClass(val);
          }
        });
        return ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
          return $(element).removeClass("error");
        });
      }
    };
    ko.bindingHandlers.validation = {
      init: function(element, valueAccessor, allBindingsAccessor) {
        var all, prop, v, validation, _i, _len, _results;

        all = allBindingsAccessor();
        prop = all.value ? all.value : all.autocomplete ? all.autocomplete : all.datetime ? all.datetime : void 0;
        if (prop) {
          validation = valueAccessor();
          if (!Array.isArray(validation)) {
            validation = [validation];
          }
          _results = [];
          for (_i = 0, _len = validation.length; _i < _len; _i++) {
            v = validation[_i];
            _results.push(prop.extend(v));
          }
          return _results;
        }
      }
    };
    return ko.bindingHandlers.val = {
      init: function(element, valueAccessor, allBindingsAccessor) {
        var interceptor, underlyingObservable, valOpts,
          _this = this;

        underlyingObservable = valueAccessor();
        valOpts = allBindingsAccessor().valOpts;
        $(element).inputmask('decimal', {
          radixPoint: ',',
          autoUnmask: true,
          clearMaskOnLostFocus: true
        });
        interceptor = ko.computed({
          read: function() {
            var val;

            val = ko.isObservable(underlyingObservable) ? underlyingObservable() : underlyingObservable;
            if (val) {
              val = val.toString();
              return val.replace(".", ",");
            }
          },
          write: function(val) {
            var fmtVal;

            fmtVal = parseFloat(val.replace(",", "."));
            return underlyingObservable(fmtVal);
          },
          deferEvaluation: true
        });
        return ko.applyBindingsToNode(element, {
          value: interceptor
        });
      }
    };
  });

}).call(this);

/*
//@ sourceMappingURL=knockout.bindings.map
*/
